## React16源码解析3-Scheduler任务调度器

### beginWork对ClassComponent更新。

这个函数的作用是对未初始化的类组件进行初始化，对已经初始化的组件更新重用。 完成组件实例的 state、props 的更新; 执行 componentWillUpdate、shouldComponentUpdate等生命周期函数； 完成组件实例的渲染； 返回下一个待处理的任务单元；
let updateQueue = workInProgress.updateQueue 取出更新队列进行批量更新。若在render之前多次调用了setState，则会产生多个update对象。这些update对象会以链表的形式存在queue中。
processUpdateQueue内部会有一个while循环对这个更新队列进行依次遍历，并计算出最终要更新的状态state。
 /**
   * 1. 完成组件实例的state、props的更新;
   * 2. componentWillUpdate、shouldComponentUpdate生命周期函数执行完毕；
   * 3. 获取是否要进行更新的标识shouldUpdate；
   */
  shouldUpdate = updateClassInstance(
    current,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime,
  );

  /**
   * 1. 如果shouldUpdate值为false，则退出渲染；
   * 2. 执行render函数
   */
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );

  // 返回下一个任务单元
  return nextUnitOfWork;
  
  ## finishClassComponent 
  
  ### 调用render产生ELement 的 DOM Tree
  调用render()获得新的子节点，并为子节点创建fiber（创建过程会尽量复用现有fiber，子节点增删也发生在这里）
 let nextChildren;
  if (
    didCaptureError &&
    typeof Component.getDerivedStateFromError !== 'function'
  ) {
    nextChildren = null;
    if (enableProfilerTimer) {
      stopProfilerTimerIfRunning(workInProgress);
    }
  } else {
    if (__DEV__) {
      setCurrentPhase('render');
      nextChildren = instance.render();
      if (
        debugRenderPhaseSideEffects ||
        (debugRenderPhaseSideEffectsForStrictMode &&
          workInProgress.mode & StrictMode)
      ) {
        instance.render();
      }
      setCurrentPhase(null);
    } else {
      nextChildren = instance.render();
    }
  }
  
  ### 这个方法的最后会调用reconcileChildren进入diff算法，这里会进入孩子节点兄弟间的遍历比对
   workInProgress.effectTag |= PerformedWork;
  // 开始 diff 算法，生成新的 children
  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(
      current,
      workInProgress,
      nextChildren,
      renderExpirationTime,
    );
  } else {
    reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderExpirationTime,
    );
  }

### 保存state
  workInProgress.memoizedState = instance.state;

  // The context might have changed so we need to recalculate it.
  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }
  
  ### 最后往下遍历
  // 最后把新的第一个 child 返回出去作为下一个工作节点
  return workInProgress.child;
